Contlog - representing numbers as continued logarithms

In his notes on continued fraction arithmetic, Gosper introduced
continued logarithms as a representation for real numbers better
suited to binary representation.  In his representation, if s is a
string of bits that represents some real number x, then the strings 1s
and 0s respresent, respectively, the numbers 2x and 1+1/x.  Assume
that the empty bit string represents infinity (oo), so that the first
few positive integers are expressed as

1: 0
2: 10
3: 1010
4: 110
5: 110110

Define the right-associative ':' operator by
x:y = 2**x + (2**x)/y
so that the expression of 5 above can be seen as
5 = 2:2:oo = 4+4/(4+1/oo)
and more generally, a binary string
(1^a)0(1^b)0(1^c)0(1^d)0...
represents the number
a:b:c:d:...

There are small problems with this representaion, but small
corrections can address them.  First, it's a representation ill suited
to fixed width fields.  Adding an extra 0 or 1 at the beginning or end
of a string changes its value, so it seems that a length must be
stored separately, or a special terminating character must be added.
It is also not immediately clear which of two given bitstrings
represents the larger of two values.  Also, numbers less than one are
not given a representation.  To address all that, define the contlog
representation of a number as follows.

An incomplete string of 0's of any length, or infinite length, represents 0.

If s is an incomplete string that represents the number x, then bx is
an incomplete string that represents the number 2x, if b is the first
bit of x, and 1+1/x if b is not the first bit of x.  If s is an
incomplete string that will have no more bits prepended to it, then
the unsigned completed string represents the number x if the first bit is 1, and
1/x if the first bit is 0.

In the unsigned contlog representation, the first few positive integers are

1: 1
2: 11
3: 1101
4: 111
5: 111001
6: 11101
7: 11101101
8: 1111
9: 11110001

and their reciprocals are the twos-complement negations of those representations:
1/1: 1
1/2: 01
1/3: 0011
1/4: 001
1/5: 000111
1/6: 00011
1/7: 00010011
1/8: 0001
1/9: 00001111

More generally, the bitstring
(1^a)(0^b)(1^c)(0^d)...
represents the number
(a-1):(b-1):(c-1):(d-1):...
and the bitstring
(0^a)(1^b)(0^c)(1^d)...
represents the reciprocal of that number.

Finally, to get signed numbers, prepend a 0 to the unsigned completed
string that represents x, and that string represents x in the signed
representation; take its twos-complement for the negative of that
value.

With 4 bits, and assuming that all the bits after the first four are
zero, the numbers that can be represented are

0000:  0/1
0001:  1/4
0010:  1/2
0011:  2/3
0100:  1/1
0101:  3/2
0110:  2/1
0111:  4/1
1000:  1/0
1001: -4/1
1010: -2/1
1011: -3/2
1100: -1/1
1101: -2/3
1110: -1/2
1111: -1/4

If two ints i and j satisfy i < j, and those bits are interpreted
instead as contlog representations of rational numbers x and y, then
necessarily x < y.

While this representation is great for representing exactly rational
numbers with small numerator and denominator in just a few bits, it
sacrifices the representation of large numbers, especially ones near
powers of two.  For example 127=6:0:5:0:4:0:3:0:2:0:1:0:0, so the
signed contlog representation of 127 requires 36 bits before the
infinite string of zeroes begins.  Computing a 32-bit approximation to
127/1 requires rounding; this implementation rounds up or down if the
truncated bits respresent a value more or less than one, and otherwise
round toward zero.

Translating that bit string back to a rational number, leads to the
result 6:0:5:0:4:0:3:0:3 = 37722176/297025, which is not likely to be
an expected result.  To provide a more expected result, this
implementation considers a fixed size bit string to represent the
interval that contains all the ratios that would be converted to that
bit string, and picks the one to represent the interval that has the
smallest denominator.  For a fixed-size bit string that ends in a
zero, that includes the values at the endpoints of the interval, and
for the others, it does not.  Otherwise, two consecutive bit strings
could map to the same ratio.  For the case of 127/1, this produces the
expect result 127/1.  For 1000/999, the result looks like 1000/999,
and not 470999/470528.
